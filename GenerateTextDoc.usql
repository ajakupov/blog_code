// Enables OUTPUT statements to generate dynamic files using column values
SET @@FeaturePreviews = "DataPartitionedOutput:on";

// The Azure blob storage account name that contains the Microsoft Academic Graph data to be used by this script
DECLARE @inputBlobAccount string = "magas-your-company-name";

// The Azure blob storage container name that contains the Microsoft Academic Graph data to be used by this script
DECLARE @inputBlobContainer string = "mag-yyyy-mm-dd";

// The Windows Azure Blob Storage (WASB) URI of the Microsoft Academic Graph data to be used by this script
DECLARE @inputUri string = "wasb://" + @inputBlobContainer + "@" + @inputBlobAccount + "/";

// The Azure blob storage account name that output files will be generated in
DECLARE @outputBlobAccount string = "academicoutput";

// The Azure blob storage container name that output files will be generated in
// ***IMPORTANT: This container must exist before running this script otherwise the script will fail
DECLARE @outputBlobContainer string = "academic-output-container";

// The Windows Azure Blob Storage (WASB) URI  that output files will be generated in
DECLARE @outputUri = "wasb://" + @outputBlobContainer + "@" + @outputBlobAccount + "/azure-search-data/{FileNumber}-data.{IndexerNumber}";

// The number of Azure Search indexers that will be used when indexing the documents generated by this script
DECLARE @maximumIndexerCount int = 6;

// The the number of files to generate for each indexer
DECLARE @maximumFileCountPerIndexer int = 500;

//
// Load academic data
//
@papers = Papers(@inputUri);

@paperAuthorAffiliations = PaperAuthorAffiliations(@inputUri);

@authors = Authors(@inputUri);

@journals = Journals(@inputUri);

@conferenceSeries = ConferenceSeries(@inputUri);

//
// Generate non-null values for optional fields to ensure we can properly join
//
@papers =
    SELECT *,
           (JournalId == null? (long) - 1 : JournalId.Value) AS JId,
           (ConferenceSeriesId == null? (long) - 1 : ConferenceSeriesId.Value) AS CId
    FROM @papers;

@paperAuthorAffiliations =
    SELECT *,
           (AffiliationId == null? (long) - 1 : AffiliationId.Value) AS AfId
    FROM @paperAuthorAffiliations;

//
// Filter and flatten paper author data into a single attribute for each paper
//
@paperAuthorsDistinct =
    SELECT DISTINCT A.PaperId,
                    A.AuthorId,

                    // NOTE: Casting AuthorSequenceNumber to nullable as MAP_AGG requires it
                    ((uint?)A.AuthorSequenceNumber) AS AuthorSequenceNumber
    FROM @paperAuthorAffiliations AS A
    INNER JOIN @papers AS P
        ON A.PaperId == P.PaperId
    OPTION(ROWCOUNT=500000000);

@paperAuthors =
    SELECT P.PaperId,
           A.NormalizedName AS AuthorName,
           P.AuthorSequenceNumber
    FROM @paperAuthorsDistinct AS P
         INNER JOIN
             @authors AS A
         ON P.AuthorId == A.AuthorId
    OPTION(ROWCOUNT=500000000);

@paperAuthorsAggregated =
    SELECT PaperId,
           "[" + string.Join(",", MAP_AGG("\"" + AuthorName + "\"", AuthorSequenceNumber).OrderBy(a => a.Value).Select(a => a.Key)) + "]" AS Authors
    FROM @paperAuthors
    GROUP BY PaperId
    OPTION(ROWCOUNT=200000000);

//
// Generate tab delimited files containing the partitioned academic data we filtered/flattened above
//
@paperDocumentFields =
    SELECT P.PaperId,
           P.Rank,
           P.Year,
           (P.JournalId == null?null : J.NormalizedName) AS Journal,
           (P.ConferenceSeriesId == null?null : C.NormalizedName) AS Conference,
           A.Authors,
           P.Volume,
           P.Issue,
           P.FirstPage,
           P.LastPage,
           P.PaperTitle,
           P.Doi,
           (int) (P.PaperId % @maximumIndexerCount) AS IndexerNumber,
           (int) (P.PaperId % @maximumFileCountPerIndexer) AS FileNumber
    FROM @papers AS P
         LEFT OUTER JOIN
             @journals AS J
         ON P.JId == J.JournalId
         LEFT OUTER JOIN
             @conferenceSeries AS C
         ON P.CId == C.ConferenceSeriesId
         LEFT OUTER JOIN
             @paperAuthorsAggregated AS A
         ON P.PaperId == A.PaperId
    OPTION(ROWCOUNT=200000000);

//
// Generates partitioned files based on the values in the ForIndexerNumber and PartitionNumber columns
//
OUTPUT @paperDocumentFields
TO @outputUri
USING Outputters.Tsv(quoting : false);